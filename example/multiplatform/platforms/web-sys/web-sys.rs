use platform_common::*;

use mmrbi::*;
use mmrbi::fs::write_if_modified_with as wimw;

use std::io::Write;



#[derive(Clone, Copy)]
pub struct WasmPackTarGz {
    pub name:   &'static str,
    pub cond:   bool,
    pub url:    &'static str,
    pub sha256: &'static str,
    pub file:   &'static str,
    pub out:    &'static str,
}

pub const WASM_PACK_VERSION : &'static str = "0.9.1";

pub const WASM_PACK_TARS : &'static [WasmPackTarGz] = &[
    WasmPackTarGz {
        name:   "wasm-pack 0.9.1",
        cond:   cfg!(target_os = "macos") && cfg!(target_arch = "x86_64"),
        url:    "https://github.com/rustwasm/wasm-pack/releases/download/v0.9.1/wasm-pack-v0.9.1-x86_64-apple-darwin.tar.gz",
        sha256: "A98C70F0A40B1689EEAF639611EC6B18D0A73ABB4A881533C8E0C2861457440F",
        file:   "wasm-pack-v0.9.1-x86_64-apple-darwin/wasm-pack",
        out:    "bin/wasm-pack-0.9.1",
    },
    WasmPackTarGz {
        name:   "wasm-pack 0.9.1",
        cond:   cfg!(target_os = "linux") && cfg!(target_arch = "x86_64"),
        url:    "https://github.com/rustwasm/wasm-pack/releases/download/v0.9.1/wasm-pack-v0.9.1-x86_64-unknown-linux-musl.tar.gz",
        sha256: "D478BD20811067566BFC88141AFCC857E7713B5385C684F6D50E7C2D549847F7",
        file:   "wasm-pack-v0.9.1-x86_64-unknown-linux-musl/wasm-pack",
        out:    "bin/wasm-pack-0.9.1",
    },
    WasmPackTarGz {
        name:   "wasm-pack 0.9.1",
        cond:   cfg!(target_os = "windows") && cfg!(target_arch = "x86_64"),
        url:    "https://github.com/rustwasm/wasm-pack/releases/download/v0.9.1/wasm-pack-v0.9.1-x86_64-pc-windows-msvc.tar.gz",
        sha256: "DEDD292BFE24756A46687E166DDD86E5DABC34CC5E43901D0EFB6FD33DA940A6",
        file:   "wasm-pack-v0.9.1-x86_64-pc-windows-msvc/wasm-pack.exe",
        out:    "bin/wasm-pack-0.9.1.exe",
    },
];



trait PackageExt                { fn generated_target(&self) -> String; }
impl  PackageExt for Package    { fn generated_target(&self) -> String { self.generated_name().replace("-", "_") } }

fn main() { platform_common::exec(Tool, "web-sys") }

fn wasm_pack() -> Command {
    let cmd = if WASM_PACK_TARS.iter().any(|wpt| wpt.cond) { "wasm-pack-0.9.1" } else { "wasm-pack" };
    let ext = if cfg!(windows) { ".exe" } else { "" };
    Command::new(format!("{}{}", cmd, ext))
}

struct Tool;
impl platform_common::Tool for Tool {
    fn setup(&self, _state: &State) {
        let rustup = mmrbi::Rustup::default().unwrap_or_else(|err| fatal!("unable to find rustup: {}", err));
        let toolchain = rustup.toolchains().active().unwrap_or_else(|| fatal!("no active rustup toolchain"));
        toolchain.targets().add("wasm32-unknown-unknown").unwrap_or_else(|err| warning!("{}", err));

        let mut any = false;
        for WasmPackTarGz { name, cond, url, sha256, file, out } in WASM_PACK_TARS.iter().copied() {
            if cond {
                any = true;
                if !std::path::Path::new(out).exists() {
                    Download { name, url, sha256 }.download_gunzip_untar_entry_to(file, out, 0o755);
                }
            }
        }

        if !any {
            cargo_local_install::run_from_strs(vec![
                "--no-path-warning",
                "wasm-pack",
                "--locked",
                "--version",
                &format!("^{}", WASM_PACK_VERSION),
            ].into_iter()).unwrap_or_else(|err| fatal!("cargo local-install wasm-pack failed: {}", err));
        }
    }

    fn generate(&self, state: &State) {
        for package in state.packages.iter() {
            let out_dir = package.generated_path();
            std::fs::create_dir_all(&out_dir).unwrap_or_else(|err| fatal!("unable to create `{}`: {}", out_dir.display(), err));

            wimw(out_dir.join("lib.rs"), |o|{
                writeln!(o, "// AUTOGENERATED BY {}", env!("CARGO_PKG_NAME"))?;
                writeln!(o)?;
                writeln!(o, "use app_common::wasm_bindgen;")?;
                writeln!(o, "use wasm_bindgen::prelude::*;")?;
                writeln!(o)?;
                writeln!(o, "#[wasm_bindgen(start)]")?;
                writeln!(o, "pub fn start() {{")?; // don't use "main" here - conflicts with wasm-pack test
                writeln!(o, "    app::init(app_common::WebSysDialogProvider);")?;
                writeln!(o, "}}")?;
                Ok(())
            }).or_die();

            wimw(out_dir.join("Cargo.toml"), |o|{
                writeln!(o, "# AUTOGENERATED BY {}", env!("CARGO_PKG_NAME"))?;
                writeln!(o)?;
                writeln!(o, "[package]")?;
                writeln!(o, "name            = {:?}", package.generated_name())?;
                writeln!(o, "version         = {:?}", package.version())?;
                writeln!(o, "description     = {:?}", package.description())?;
                writeln!(o, "publish         = false")?;
                writeln!(o, "edition         = {:?}", "2018")?;
                writeln!(o)?;
                writeln!(o, "[dependencies]")?;
                writeln!(o, "app-common      = {{ path = {:?}, features = [{:?}] }}", "../../../../app-common", "platform-web-sys")?;
                writeln!(o, "app             = {{ path = {:?}, package = {:?} }}",    package.original_path(), package.original_name())?;
                writeln!(o)?;
                writeln!(o, "[lib]")?;
                writeln!(o, "crate-type      = [\"cdylib\", \"rlib\"]")?;
                writeln!(o, "name            = {:?}", package.generated_name().replace("-", "_"))?;
                writeln!(o, "path            = {:?}", "lib.rs")?;
                Ok(())
            }).or_die();
        }
    }

    fn build(&self, state: &State) {
        for config in state.configs.iter() {
            for package in state.packages.iter() {
                let mut cmd = wasm_pack();
                cmd.current_dir(package.generated_path());
                let pkg_dir = format!("../../../../target/wasm32-unknown-unknown/{config}/{package}", config=config.name(), package=package.generated_name());
                cmd.args(&["build", "--no-typescript", "--target", "no-modules", "--out-dir", &pkg_dir]);
                match config.name() {
                    "debug"     => { cmd.arg("--dev"); },
                    "release"   => { cmd.arg("--profiling"); }, // release + debuginfo
                    other       => fatal!("unexpected config: {:?}", other),
                }
                cmd.io0(filter_stdout, filter_stderr).or_die();

                wimw(format!("target/wasm32-unknown-unknown/{config}/{package}/index.html", config=config.name(), package=package.generated_name()), |o|{
                    writeln!(o, "<!DOCTYPE html>")?;
                    writeln!(o, "<html lang=\"en\"><head>")?;
                    writeln!(o, "    <meta charset=\"UTF-8\">")?;
                    writeln!(o, "    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">")?;
                    writeln!(o, "    <title>{}</title>", package.original_name())?;
                    writeln!(o, "</head><body>")?;
                    // what did these do again? IE pollyfills perhaps?
                    //writeln!(o, "    <script src="https://unpkg.com/text-encoding@0.6.4/lib/encoding-indexes.js"></script>")?;
                    //writeln!(o, "    <script src="https://unpkg.com/text-encoding@0.6.4/lib/encoding.js"></script>")?;
                    writeln!(o, "    <script src=\"{}.js\"></script>", package.generated_target())?;
                    writeln!(o, "    <script>")?;
                    writeln!(o, "        // fetch doesn't work over file:// despite using --allow-file-access-from-files, so use XHR instead.")?;
                    writeln!(o, "        var xhr = new XMLHttpRequest();")?;
                    writeln!(o, "        xhr.responseType = \"arraybuffer\";")?;
                    writeln!(o, "        xhr.addEventListener(\"error\", function(err) {{")?;
                    writeln!(o, "            debugger;")?;
                    writeln!(o, "        }});")?;
                    writeln!(o, "        xhr.addEventListener(\"load\", function(load) {{")?;
                    writeln!(o, "            wasm_bindgen(xhr.response); // .then(...)")?;
                    writeln!(o, "        }});")?;
                    writeln!(o, "        xhr.open(\"GET\", \"{}_bg.wasm\");", package.generated_target())?;
                    writeln!(o, "        xhr.send();")?;
                    writeln!(o, "    </script>")?;
                    writeln!(o, "</body></html>")?;
                    Ok(())
                }).or_die();
            }
        }
    }

    fn test(&self, state: &State) {
        for config in state.configs.iter() {
            for package in state.packages.iter() {
                let mut cmd = wasm_pack();
                cmd.current_dir(package.generated_path());
                cmd.args(&["test", "--headless"]);

                // XXX: make this configurable somehow?  or auto-infer from installed browsers?
                //cmd.arg("--node");
                cmd.arg("--chrome");
                //cmd.arg("--firefox");
                //cmd.arg("--safari");

                match config.name() {
                    "debug"     => {},
                    "release"   => { cmd.arg("--release"); },
                    other       => fatal!("unexpected config: {:?}", other),
                }
                cmd.io0(filter_stdout, filter_stderr).or_die();
            }
        }
    }
}

fn filter_stderr(line: &str) {
    if line.starts_with("[INFO]: ") { return } // so much spam, none of which is useful:
    // [INFO]: Checking for the Wasm target...
    // [INFO]: Compiling to Wasm...
    // [INFO]: Installing wasm-bindgen...
    // [INFO]: Optimizing wasm binaries with `wasm-opt`...
    // [INFO]: Optional fields missing from Cargo.toml: 'repository', 'license'. These are not necessary, but recommended
    // [INFO]: :-) Done in 0.66s
    // [INFO]: :-) Your wasm pkg is ready to publish at C:\local\cargo-container-g\example\multiplatform\.container\crates\platform-web-sys\alpha\../../../../target/wasm32-unknown-unknown/debug/alpha-web-sys.

    if line.starts_with(":-) [WARN]: origin crate has no README") { return } // yes, I know, that's bloody intentional

    let trim = line.trim_start();
    if      trim.starts_with("Finished ")   {} // too much spam
    else if trim.starts_with("Compiling ")  { status!("Compiling", "{}", &trim["Compiling ".len()..]); }
    else                                    { eprintln!("{}", line); }
}

fn filter_stdout(line: &str) {
    println!("{}", line);
}
