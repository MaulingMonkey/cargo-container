use platform_common::*;

use mmrbi::*;
use mmrbi::fs::write_if_modified_with as wimw;

use std::io::Write;



trait PackageExt                { fn generated_target(&self) -> String; }
impl  PackageExt for Package    { fn generated_target(&self) -> String { self.generated_name().replace("-", "_") } }

fn main() { platform_common::exec(Tool, "web-sys") }

struct Tool;
impl platform_common::Tool for Tool {
    fn generate(&self, state: &State) {
        for package in state.packages.iter() {
            let out_dir = package.generated_path();
            std::fs::create_dir_all(&out_dir).unwrap_or_else(|err| fatal!("unable to create `{}`: {}", out_dir.display(), err));

            wimw(out_dir.join("lib.rs"), |o|{
                writeln!(o, "// AUTOGENERATED BY {}", env!("CARGO_PKG_NAME"))?;
                writeln!(o)?;
                writeln!(o, "use app_common::wasm_bindgen;")?;
                writeln!(o, "use wasm_bindgen::prelude::*;")?;
                writeln!(o)?;
                writeln!(o, "#[wasm_bindgen(start)]")?;
                writeln!(o, "pub fn start() {{")?; // don't use "main" here - conflicts with wasm-pack test
                writeln!(o, "    app::init(app_common::WebSysDialogProvider);")?;
                writeln!(o, "}}")?;
                Ok(())
            }).or_die();

            wimw(out_dir.join("Cargo.toml"), |o|{
                writeln!(o, "# AUTOGENERATED BY {}", env!("CARGO_PKG_NAME"))?;
                writeln!(o)?;
                writeln!(o, "[package]")?;
                writeln!(o, "name            = {:?}", package.generated_name())?;
                writeln!(o, "version         = {:?}", package.version())?;
                writeln!(o, "description     = {:?}", package.description())?;
                writeln!(o, "publish         = false")?;
                writeln!(o, "edition         = {:?}", "2018")?;
                writeln!(o)?;
                writeln!(o, "[dependencies]")?;
                writeln!(o, "app-common      = {{ path = {:?}, features = [{:?}] }}", "../../../../app-common", "platform-web-sys")?;
                writeln!(o, "app             = {{ path = {:?}, package = {:?} }}",    package.original_path(), package.original_name())?;
                writeln!(o)?;
                writeln!(o, "[lib]")?;
                writeln!(o, "crate-type      = [\"cdylib\", \"rlib\"]")?;
                writeln!(o, "name            = {:?}", package.generated_name().replace("-", "_"))?;
                writeln!(o, "path            = {:?}", "lib.rs")?;
                Ok(())
            }).or_die();
        }
    }

    fn build(&self, state: &State) {
        for config in state.configs.iter() {
            for package in state.packages.iter() {
                let mut cmd = Command::new("wasm-pack");
                cmd.current_dir(package.generated_path());
                let pkg_dir = format!("../../../../target/wasm32-unknown-unknown/{config}/{package}", config=config.name(), package=package.generated_name());
                cmd.args(&["build", "--no-typescript", "--target", "no-modules", "--out-dir", &pkg_dir]);
                match config.name() {
                    "debug"     => { cmd.arg("--dev"); },
                    "release"   => { cmd.arg("--profiling"); }, // release + debuginfo
                    other       => fatal!("unexpected config: {:?}", other),
                }
                cmd.io0(filter_stdout, filter_stderr).or_die();

                wimw(format!("target/wasm32-unknown-unknown/{config}/{package}/index.html", config=config.name(), package=package.generated_name()), |o|{
                    writeln!(o, "<!DOCTYPE html>")?;
                    writeln!(o, "<html lang=\"en\"><head>")?;
                    writeln!(o, "    <meta charset=\"UTF-8\">")?;
                    writeln!(o, "    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">")?;
                    writeln!(o, "    <title>{}</title>", package.original_name())?;
                    writeln!(o, "</head><body>")?;
                    // what did these do again? IE pollyfills perhaps?
                    //writeln!(o, "    <script src="https://unpkg.com/text-encoding@0.6.4/lib/encoding-indexes.js"></script>")?;
                    //writeln!(o, "    <script src="https://unpkg.com/text-encoding@0.6.4/lib/encoding.js"></script>")?;
                    writeln!(o, "    <script src=\"{}.js\"></script>", package.generated_target())?;
                    writeln!(o, "    <script>")?;
                    writeln!(o, "        // fetch doesn't work over file:// despite using --allow-file-access-from-files, so use XHR instead.")?;
                    writeln!(o, "        var xhr = new XMLHttpRequest();")?;
                    writeln!(o, "        xhr.responseType = \"arraybuffer\";")?;
                    writeln!(o, "        xhr.addEventListener(\"error\", function(err) {{")?;
                    writeln!(o, "            debugger;")?;
                    writeln!(o, "        }});")?;
                    writeln!(o, "        xhr.addEventListener(\"load\", function(load) {{")?;
                    writeln!(o, "            wasm_bindgen(xhr.response); // .then(...)")?;
                    writeln!(o, "        }});")?;
                    writeln!(o, "        xhr.open(\"GET\", \"{}_bg.wasm\");", package.generated_target())?;
                    writeln!(o, "        xhr.send();")?;
                    writeln!(o, "    </script>")?;
                    writeln!(o, "</body></html>")?;
                    Ok(())
                }).or_die();
            }
        }
    }

    fn test(&self, state: &State) {
        for config in state.configs.iter() {
            for package in state.packages.iter() {
                let mut cmd = Command::new("wasm-pack");
                cmd.current_dir(package.generated_path());
                cmd.args(&["test", "--headless"]);

                // XXX: make this configurable somehow?  or auto-infer from installed browsers?
                //cmd.arg("--node");
                cmd.arg("--chrome");
                //cmd.arg("--firefox");
                //cmd.arg("--safari");

                match config.name() {
                    "debug"     => {},
                    "release"   => { cmd.arg("--release"); },
                    other       => fatal!("unexpected config: {:?}", other),
                }
                cmd.io0(filter_stdout, filter_stderr).or_die();
            }
        }
    }
}

fn filter_stderr(line: &str) {
    if line.starts_with("[INFO]: ") { return } // so much spam, none of which is useful:
    // [INFO]: Checking for the Wasm target...
    // [INFO]: Compiling to Wasm...
    // [INFO]: Installing wasm-bindgen...
    // [INFO]: Optimizing wasm binaries with `wasm-opt`...
    // [INFO]: Optional fields missing from Cargo.toml: 'repository', 'license'. These are not necessary, but recommended
    // [INFO]: :-) Done in 0.66s
    // [INFO]: :-) Your wasm pkg is ready to publish at C:\local\cargo-container-g\example\multiplatform\.container\crates\platform-web-sys\alpha\../../../../target/wasm32-unknown-unknown/debug/alpha-web-sys.

    if line.starts_with(":-) [WARN]: origin crate has no README") { return } // yes, I know, that's bloody intentional

    let trim = line.trim_start();
    if      trim.starts_with("Finished ")   {} // too much spam
    else if trim.starts_with("Compiling ")  { status!("Compiling", "{}", &trim["Compiling ".len()..]); }
    else                                    { eprintln!("{}", line); }
}

fn filter_stdout(line: &str) {
    println!("{}", line);
}
