#![cfg_attr(unix, allow(dead_code))]
#![cfg_attr(unix, allow(unused_imports))]

#[path="windows/_windows.rs"] mod windows;

use platform_common::*;

use mmrbi::*;
use mmrbi::fs::write_if_modified_with as wimw;

use std::io::Write;
use std::path::PathBuf;



const DISTRO_ID : &'static str = "cargo-container-platforms-opendingux-1";
const PFNS : &'static [&'static str] = &[
    "CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc",      // Ubuntu (16.04)
    "CanonicalGroupLimited.Ubuntu16.04onWindows_79rhkp1fndgsc", // Ubuntu 16.04 via https://aka.ms/wsl-ubuntu-1604
    "CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc", // Ubuntu 18.04 via https://aka.ms/wsl-ubuntu-1804
    "CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc", // Ubuntu 20.04 via ???
];

const GCW0_TOOLCHAIN_ENTRIES : usize = 30591 + 2160; // files + dirs for tar progress
const GCW0_TOOLCHAIN : Download = Download {
    name:   "opendingux gcw0 toolchain (2014-08-20)",
    url:    "http://www.gcw-zero.com/files/opendingux-gcw0-toolchain.2014-08-20.tar.bz2",
    //url:    concat!("file:///C:/Users/", env!("USERNAME"), "/Downloads/opendingux-gcw0-toolchain.2014-08-20.tar.bz2"),
    sha256: "3632C85F48879108D4349570DED60D87D7A324850B81D683D031E4EE112BAAA0",
};

const UBUNTU_PFN : &'static str = "CanonicalGroupLimited.Ubuntu16.04onWindows_79rhkp1fndgsc";
const UBUNTU_APPX : Download = Download {
    name:   "ubuntu 16.04",
    url:    "https://aka.ms/wsl-ubuntu-1604",
    //url:    concat!("file:///C:/Users/", env!("USERNAME"), "/Downloads/Ubuntu_1604.2019.523.0_x64.appx"),
    sha256: "55782021E04F52D071814FDAD02CD37448C7A49F2EF5A66899F3D5BC7D79859F",
};

fn distros() -> impl Iterator<Item = &'static str> {
    if env::has_var("CI") {&[
        DISTRO_ID,
        // For CI, consider just using whatever VMs are already installed, if any.
        "Ubuntu",
        "Ubuntu-16.04", // Appveyor
        "Ubuntu-18.04", // Appveyor
        "Ubuntu-20.04", // Appveyor
        "openSUSE-42",  // Appveyor
    ][..]} else {&[
        DISTRO_ID,
    ][..]}.iter().copied()
}



fn main() {
    #[cfg(windows)] {
        // shenannigans to work around WslLaunch's weird behavior
        let mut args = std::env::args_os();
        let _exe = args.next();
        if args.next().map_or(false, |arg| arg == "wsl-register-distro-hack") {
            let wsl = wslapi::Library::new().unwrap();
            let distro = args.next().expect("distro");
            let file   = PathBuf::from(args.next().expect("file"));
            wsl.register_distribution(distro, file).or_die();
            std::process::exit(0);
        }
    }
    platform_common::exec(Tool, "opendingux")
}

struct Tool;
impl platform_common::Tool for Tool {
    fn setup(&self, _state: &State) {
        windows::features::require("Microsoft-Windows-Subsystem-Linux");    // WSL 1 (required)
        //windows::features::require("VirtualMachinePlatform");             // WSL 2 (optional)

        if cfg!(target_os = "windows") {
            #[cfg(windows)] {
                let wsl = wslapi::Library::new().unwrap_or_else(|err| fatal!(
                    "unable to check/install a distro for opendingux builds: WSL not available ({})!  You may need to install WSL, or restart if you recently did.",
                    err
                ));
                let distro = windows::wsl::ensure_distro_installed(&wsl);
                windows::wsl::ensure_root_stuff(&wsl, distro);
                windows::wsl::ensure_gcw0_installed(&wsl, distro);
            }
        } else if cfg!(target_os = "linux") {
            // ...
        } else {
            // ...?
        }
    }

    fn generate(&self, state: &State) {
        for package in state.packages.iter() {
            let out_dir = package.generated_path();
            std::fs::create_dir_all(&out_dir).unwrap_or_else(|err| fatal!("unable to create `{}`: {}", out_dir.display(), err));

            wimw(out_dir.join("main.rs"), |o|{
                writeln!(o, "// AUTOGENERATED BY {}", env!("CARGO_PKG_NAME"))?;
                writeln!(o)?;
                writeln!(o, "fn main() {{ app::init(app_common::ConsoleDialogProvider) }}")?;
                Ok(())
            }).or_die();

            wimw(out_dir.join("Cargo.toml"), |o|{
                writeln!(o, "# AUTOGENERATED BY {}", env!("CARGO_PKG_NAME"))?;
                writeln!(o)?;
                writeln!(o, "[package]")?;
                writeln!(o, "name            = {:?}", package.generated_name())?;
                writeln!(o, "version         = {:?}", package.version())?;
                writeln!(o, "description     = {:?}", package.description())?;
                writeln!(o, "publish         = false")?;
                writeln!(o, "edition         = {:?}", "2018")?;
                writeln!(o)?;
                writeln!(o, "[dependencies]")?;
                writeln!(o, "app-common      = {{ path = {:?}, features = [{:?}] }}", "../../../../app-common", "platform-console")?;
                writeln!(o, "app             = {{ path = {:?}, package = {:?} }}",    package.original_path(), package.original_name())?;
                writeln!(o)?;
                writeln!(o, "[[bin]]")?;
                writeln!(o, "name            = {:?}", package.original_name())?;
                writeln!(o, "path            = {:?}", "main.rs")?;
                Ok(())
            }).or_die();
        }
    }

    fn build(&self, _state: &State) {
        return;
    }

    fn test(&self, _state: &State) {
        return;
    }
}
