use platform_common::*;

use mmrbi::*;
use mmrbi::env::*;
use mmrbi::fs::write_if_modified_with as wimw;

use std::ffi::OsString;
use std::io::Write;



#[derive(Clone, Copy)]
pub struct CargoWebGz {
    pub name:   &'static str,
    pub cond:   bool,
    pub url:    &'static str,
    pub sha256: &'static str,
    pub out:    &'static str,
}

pub const CARGO_WEB_VERSION : &'static str = "0.6.26";

pub const CARGO_WEB_GZS : &'static [CargoWebGz] = &[
    CargoWebGz {
        name:   "cargo-web 0.6.26",
        cond:   cfg!(target_os = "macos") && cfg!(target_arch = "x86_64"),
        url:    "https://github.com/koute/cargo-web/releases/download/0.6.26/cargo-web-x86_64-apple-darwin.gz",
        sha256: "010AF3A9E87F925B75AD03BA729864F96490E720C4BFED82B57AA42B64E14B08",
        out:    "bin/cargo-web-0.6.26",
    },
    CargoWebGz {
        name:   "cargo-web 0.6.26",
        cond:   cfg!(target_os = "linux") && cfg!(target_arch = "x86_64"),
        url:    "https://github.com/koute/cargo-web/releases/download/0.6.26/cargo-web-x86_64-unknown-linux-gnu.gz",
        sha256: "FF4187FC27A9A98CAE331BE2F17042F2D27BA508DA108F886E0893EF30825629",
        out:    "bin/cargo-web-0.6.26",
    },
];



fn main() { platform_common::exec(Tool, "stdweb") }

fn cargo_web() -> Command {
    let mut c = Command::new("cargo");
    c.arg(if CARGO_WEB_GZS.iter().any(|wpt| wpt.cond) { "web-0.6.26" } else { "web" });
    c
}

struct Tool;
impl platform_common::Tool for Tool {
    fn setup(&self, _state: &State) {
        let rustup = mmrbi::Rustup::default().or_die();
        let toolchain = rustup.toolchains().active().ok_or("no active rustup toolchain").or_die();
        toolchain.targets().add("wasm32-unknown-unknown").unwrap_or_else(|err| warning!("{}", err));

        let mut any = false;
        for CargoWebGz { name, cond, url, sha256, out } in CARGO_WEB_GZS.iter().copied() {
            if cond {
                any = true;
                if !std::path::Path::new(out).exists() {
                    Download { name, url, sha256 }.download_gunzip_to(out);
                }
            }
        }

        if !any {
            cargo_local_install::run_from_strs(vec![
                "--no-path-warning",
                "cargo-web",
                "--locked",
                "--version",
                &format!("^{}", CARGO_WEB_VERSION),
            ].into_iter()).or_die();
        }
    }

    fn generate(&self, state: &State) {
        for package in state.packages.iter() {
            let out_dir = package.generated_path();
            std::fs::create_dir_all(&out_dir).unwrap_or_else(|err| fatal!("unable to create `{}`: {}", out_dir.display(), err));

            wimw(out_dir.join("main.rs"), |o|{
                writeln!(o, "// AUTOGENERATED BY {}", env!("CARGO_PKG_NAME"))?;
                writeln!(o)?;
                writeln!(o, "fn main() {{ app::init(app_common::StdwebDialogProvider) }}")?;
                Ok(())
            }).or_die();

            wimw(out_dir.join("Cargo.toml"), |o|{
                writeln!(o, "# AUTOGENERATED BY {}", env!("CARGO_PKG_NAME"))?;
                writeln!(o)?;
                writeln!(o, "[package]")?;
                writeln!(o, "name            = {:?}", package.generated_name())?;
                writeln!(o, "version         = {:?}", package.version())?;
                writeln!(o, "description     = {:?}", package.description())?;
                writeln!(o, "publish         = false")?;
                writeln!(o, "edition         = {:?}", "2018")?;
                writeln!(o)?;
                writeln!(o, "[dependencies]")?;
                writeln!(o, "app-common      = {{ path = {:?}, features = [{:?}] }}", "../../../../app-common", "platform-stdweb")?;
                writeln!(o, "app             = {{ path = {:?}, package = {:?} }}",    package.original_path(), package.original_name())?;
                writeln!(o)?;
                writeln!(o, "[[bin]]")?;
                writeln!(o, "name            = {:?}", package.generated_name())?;
                writeln!(o, "path            = {:?}", "main.rs")?;
                Ok(())
            }).or_die();
        }
    }

    fn build(&self, state: &State) {
        for config in state.configs.iter() {
            for package in state.packages.iter() {
                let mut cmd = cargo_web();
                cmd.current_dir(package.generated_path());
                cmd.args(&["build"]);
                match config.name() {
                    "debug"     => {},
                    "release"   => { cmd.arg("--release"); },
                    other       => fatal!("unexpected config: {:?}", other),
                }
                cmd.io0(filter_stdout, filter_stderr).or_die();

                wimw(format!("target/wasm32-unknown-unknown/{config}/{package}.html", config=config.name(), package=package.generated_name()), |o|{
                    writeln!(o, "<!DOCTYPE html>")?;
                    writeln!(o, "<html lang=\"en\"><head>")?;
                    writeln!(o, "    <meta charset=\"UTF-8\">")?;
                    writeln!(o, "    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">")?;
                    writeln!(o, "    <title>{}</title>", package.original_name())?;
                    writeln!(o, "</head><body>")?;
                    writeln!(o, "    <script src=\"../stdweb-hacks.js\"></script>")?;
                    writeln!(o, "    <script src=\"{}.js\"></script>", package.generated_name())?;
                    writeln!(o, "</body></html>")?;
                    Ok(())
                }).or_die();
            }
        }
        wimw("target/wasm32-unknown-unknown/stdweb-hacks.js", |o| write!(o, "{}", include_str!("stdweb-hacks.js"))).or_die();
    }

    fn test(&self, state: &State) {
        if rustc::version().or_die().is_after(1, 43, 0) { // last known good rustc version
            warning!("skipping tests - `cargo web test` is broken on rustc 1.44+ (see https://github.com/koute/cargo-web/issues/243 for details)");
            return;
        }

        let path = {
            let mut o = OsString::new();
            if cfg!(windows) {
                if let Some(pf86) = opt_var_os("ProgramFiles(x86)") {
                    o.push(pf86);
                    o.push(r"\Google\Chrome\Application\;");
                } else if let Some(pf) = opt_var_os("ProgramFiles") {
                    o.push(pf);
                    o.push(r"\Google\Chrome\Application\;");
                } else if let Some(pf64) = opt_var_os("ProgramW6432") {
                    o.push(pf64);
                    o.push(r"\Google\Chrome\Application\;");
                } else {
                    o.push(r"C:\Program Files (x86)\Google\Chrome\Application\;");
                    o.push(r"C:\Program Files\Google\Chrome\Application\;");
                }
            }
            o.push(req_var_os("PATH"));
            o
        };

        for config in state.configs.iter() {
            for package in state.packages.iter() {
                let mut cmd = cargo_web();
                cmd.current_dir(package.generated_path());
                cmd.args(&["test"]);
                cmd.env("PATH", &path);
                match config.name() {
                    "debug"     => {},
                    "release"   => { cmd.arg("--release"); },
                    other       => fatal!("unexpected config: {:?}", other),
                }
                cmd.io0(filter_stdout, filter_stderr).or_die();
            }
        }
    }
}

fn filter_stderr(line: &str) {
    let trim = line.trim();
    
    if      trim.starts_with("Processing \"") && trim.ends_with(".wasm\"...")   { status!("Processing", "{}", &trim["Processing \"".len()..trim.len()-"\"...".len()]); }
    else if trim.starts_with("Compiling ")                                      { status!("Compiling",  "{}", &trim["Compiling ".len()..]); }
    else if trim.starts_with("Finished ")                                       {} // too much spam
    else                                                                        { eprintln!("{}", line); }
}

fn filter_stdout(line: &str) {
    println!("{}", line);
}
